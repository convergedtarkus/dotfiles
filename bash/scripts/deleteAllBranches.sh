#!/bin/bash
#
# ARG_HELP([The general script's help msg])
# ARG_POSITIONAL_SINGLE([remote],[Remote, defaults to remove local branches],[local])
# ARG_OPTIONAL_BOOLEAN([delete],[d],[Whether to actaully delete anything or dry-run only],[off])
# ARG_OPTIONAL_BOOLEAN([branches],[b],[Whether to delete branches],[on])
# ARG_OPTIONAL_BOOLEAN([tags],[t],[Whether to delete tags, ignore if running on local],[off])
# ARG_OPTIONAL_BOOLEAN([printOnly],[p],[Only print refs to be deleted, do nothing else],[off])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.4.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die() {
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option() {
	local first_option all_short_options
	all_short_options='hdbtp'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_remote="local"
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_delete=off
_arg_branches=on
_arg_tags=off
_arg_printonly=off

print_help() {
	echo "The general script's help msg"
	printf 'Usage: %s [-h|--help] [-d|--(no-)delete] [-b|--(no-)branches] [-t|--(no-)tags] [-p|--(no-)printOnly] [<remote>]\n' "$0"
	printf "\t%s\n" "<remote>: Remote, defaults to remove local branches (default: '""local""')"
	printf "\t%s\n" "-h,--help: Prints help"
	printf "\t%s\n" "-d,--delete,--no-delete: Whether to actaully delete anything or dry-run only (off by default)"
	printf "\t%s\n" "-b,--branches,--no-branches: Whether to delete branches (on by default)"
	printf "\t%s\n" "-t,--tags,--no-tags: Whether to delete tags, ignore if running on local (off by default)"
	printf "\t%s\n" "-p,--printOnly,--no-printOnly: Only print refs to be deleted, do nothing else (off by default)"
}

# THE PARSING ITSELF
while test $# -gt 0; do
	_key="$1"
	case "$_key" in
	-h* | --help)
		print_help
		exit 0
		;;
	-d* | --no-delete | --delete)
		_arg_delete="on"
		_next="${_key##-d}"
		if test -n "$_next" -a "$_next" != "$_key"; then
			begins_with_short_option "$_next" && shift && set -- "-d" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
		fi
		test "${1:0:5}" = "--no-" && _arg_delete="off"
		;;
	-b* | --no-branches | --branches)
		_arg_branches="on"
		_next="${_key##-b}"
		if test -n "$_next" -a "$_next" != "$_key"; then
			begins_with_short_option "$_next" && shift && set -- "-b" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
		fi
		test "${1:0:5}" = "--no-" && _arg_branches="off"
		;;
	-t* | --no-tags | --tags)
		_arg_tags="on"
		_next="${_key##-t}"
		if test -n "$_next" -a "$_next" != "$_key"; then
			begins_with_short_option "$_next" && shift && set -- "-t" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
		fi
		test "${1:0:5}" = "--no-" && _arg_tags="off"
		;;
	-p* | --no-printOnly | --printOnly)
		_arg_printonly="on"
		_next="${_key##-p}"
		if test -n "$_next" -a "$_next" != "$_key"; then
			begins_with_short_option "$_next" && shift && set -- "-p" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
		fi
		test "${1:0:5}" = "--no-" && _arg_printonly="off"
		;;
	*)
		_positionals+=("$1")
		;;
	esac
	shift
done

_positional_names=('_arg_remote')
test ${#_positionals[@]} -gt 1 && _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 0 and 1, but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
for ((ii = 0; ii < ${#_positionals[@]}; ii++)); do
	eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
done

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

#echo "Value of remote: $_arg_remote"
#echo "Actually delete: $_arg_delete"
#echo "Delete branches: $_arg_branches"
#echo "Delete tags: $_arg_tags"
#echo "Print only: $_arg_printonly"

# ] <-- needed because of Argbash

#--------------------------------------------------------------------------
# Argument parsing above
#--------------------------------------------------------------------------

#--------------------------------------------------------------------------
# Script functions below
#--------------------------------------------------------------------------

getRemoteRefs() {
	local getBranchesCommand="git ls-remote"

	if [ "$_arg_branches" == "on" ]; then
		getBranchesCommand="$getBranchesCommand --heads"
	fi

	if [ "$_arg_tags" == "on" ]; then
		getBranchesCommand="$getBranchesCommand --tags"
	fi

	if [ "$getBranchesCommand" == "git ls-remote" ]; then
		echo "Don't delete branches or tags? What is it you want me to do?"
		echo "I'm just going to delete a random branch, hang on a second"
		exit 1
	fi

	local getBranchesCommand="$getBranchesCommand $_arg_remote"
	local allBranches=$(eval $getBranchesCommand)

	# remove the commit hash ("07c89a172f77da64351e0a178760d70046095b3e refs/tags/0.0.11" => "refs/tags/0.0.11")
	local refNamesOnly=$(echo "$allBranches" | cut -d$'\t' -f2)

	# Remove master from the list
	refNamesOnly=$(echo "$refNamesOnly" | grep -v '^refs/heads/master$')

	# something something tags, something something lightwieght vs annotated, lets play safe and remove them (https://stackoverflow.com/questions/15472107/when-listing-git-ls-remote-why-theres-after-the-tag-name/15472310#15472310)
	refNamesOnly=$(echo "$refNamesOnly" | grep -v '.*\^{}')

	# git push $_arg_remote -d $line or git push $_arg_remote :$line
	echo "$refNamesOnly"
}

getLogString() {
	local logString=""

	if [ "$_arg_branches" == "on" ]; then
		logString="branches"
	fi

	if [ "$_arg_tags" == "on" ]; then
		if [ "$logString" == "" ]; then
			logString="tags"
		else
			logString="$logString and tags"
		fi
	fi

	echo "$logString"
}

#--------------------------------------------------------------------------
# Main script logic below
#--------------------------------------------------------------------------

if [ "$_arg_remote" == "local" ]; then
	echo "Local not supported yet"
	exit 1
fi

# TODO Add local (and force) support

# get all branches
refNamesOnly=$(getRemoteRefs)
logString=$(getLogString)

# git push $_arg_remote -d $line or git push $_arg_remote :$line
deleteCommand="git push $_arg_remote"

if [ $_arg_delete != "on" ]; then
	# run with --dry-run (no deleting) if correct parameter not given
	echo "Running with --dry-run becuase you don't know what you're doing"
	deleteCommand="$deleteCommand --dry-run --delete"
else
	# make sure they know what they are doing before allowing live delete
	reproName=$(basename $(git rev-parse --show-toplevel))
	echo "Are you sure you know what you're doing for remote: '$_arg_remote' of repro: '$reproName' deleting $logString?"
	read input_variable
	if [ "$input_variable" != "y" ] && [ "$input_variable" != "Y" ]; then
		echo "Close call there, aborting delete"
		exit 0
	else
		echo "Don't say I didn't warn you"
		deleteCommand="$deleteCommand --delete"
	fi
fi

if [ "$refNamesOnly" == "" ]; then
	echo "Nothing to delete, exiting"
	exit 0
fi

if [ "$_arg_printonly" == "on" ]; then
	echo "Printing all refs to be deleted and exiting"
	echo "$refNamesOnly"
	exit 1
fi

echo ""
echo "Will delete all the following remote refs"
echo "$refNamesOnly"

echo "You have 10 seconds to cancel if the above refs look wrong"
echo ""

sleep 10 # Waits 10 seconds.

echo "Deleting all requested remote refs"
echo ""

# Put all the refs into a single line so one command can be run
commandRefs=$(echo "$refNamesOnly" | tr '\n' ' ')

deleteBranchCommand="$deleteCommand $commandRefs"
${deleteBranchCommand}
